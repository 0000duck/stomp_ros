#ifndef OPENVDB_DISTANCE_FIELD_H
#define OPENVDB_DISTANCE_FIELD_H

#include <geometric_shapes/shapes.h>
#include <Eigen/Core>
#include <Eigen/Eigen>
#include <moveit/robot_state/robot_state.h>
#include <openvdb/openvdb.h>
#include <openvdb/tools/MeshToVolume.h>
#include <openvdb/math/Vec3.h>
#include <industrial_collision_detection/collision_common.h>
#include <openvdb_visualization.h>

namespace distance_field
{

typedef std::vector<std::pair<openvdb::math::Vec3d, double> > SphereModel;
typedef boost::shared_ptr<std::vector<std::pair<openvdb::math::Vec3d, double> > > SphereModelPtr;

struct MeshData
{
  std::vector<openvdb::math::Vec3s> points;
  std::vector<openvdb::Vec3I> triangles;
  std::vector<openvdb::Vec4I> quads;
};

class OpenVDBDistanceField
{

public:
    OpenVDBDistanceField(float voxel_size = 0.01, float background = 0.5);

    /**
     * @brief Creates a new 'OpenVDBDistanceField' using the data & meta-data associated
     * with the given grid pointer.
     * @param grid A valid pointer to a grid previously generated by this class. Should
     * contain pertinent meta-data such as 'voxel_size'.
     */
    OpenVDBDistanceField(openvdb::FloatGrid::Ptr grid);

    double getDistance(const Eigen::Vector3f &point, bool thread_safe = true) const;

    double getDistance(const openvdb::math::Coord &coord, bool thread_safe = true) const;

    double getDistance(const float &x, const float &y, const float &z, bool thread_safe = true) const;

    bool getGradient(const Eigen::Vector3f &point, Eigen::Vector3d &gradient, bool thread_safe = true) const;

    bool getGradient(const openvdb::math::Coord &coord, Eigen::Vector3d &gradient, bool thread_safe = true) const;

    bool getGradient(const float &x, const float &y, const float &z, Eigen::Vector3d &gradient, bool thread_safe = true) const;

    void addShapeToField(const shapes::Shape *shape,
                         const Eigen::Affine3d &pose,
                         const float exBandWidth = openvdb::LEVEL_SET_HALF_WIDTH,
                         const float inBandWidth = openvdb::LEVEL_SET_HALF_WIDTH);

    void addLinkToField(const robot_model::LinkModel *link,
                        const Eigen::Affine3d &pose,
                        const float exBandWidth = openvdb::LEVEL_SET_HALF_WIDTH,
                        const float inBandWidth = openvdb::LEVEL_SET_HALF_WIDTH);


    void fillWithSpheres(SphereModel &spheres,
                         int maxSphereCount,
                         bool overlapping = false,
                         float minRadius = 1.0,
                         float maxRadius = std::numeric_limits<float>::max(),
                         float isovalue = 0.0,
                         int instanceCount = 10000);

    void writeToFile(const std::string file_path);

    uint64_t memUsage() const;

    double getVoxelSize() const;

    openvdb::math::Transform::Ptr getTransform() const;

    openvdb::FloatGrid::Ptr getGrid() const;

private:

    float voxel_size_;
    float background_;
    openvdb::FloatGrid::Ptr grid_;
    std::shared_ptr<openvdb::FloatGrid::ConstAccessor> accessor_;
    openvdb::math::Transform::Ptr transform_;
};

typedef boost::shared_ptr<OpenVDBDistanceField> OpenVDBDistanceFieldPtr;
typedef boost::shared_ptr<const OpenVDBDistanceField> OpenVDBDistanceFieldConstPtr;


MeshData ShapeMeshToOpenVDB(const shapes::Mesh *mesh, const Eigen::Affine3d &pose);

void Affine3dToMat4d(const Eigen::Affine3d &input, openvdb::math::Mat4d &output);

void Affine3dToMat4dAffine(const Eigen::Affine3d &input, openvdb::math::Mat4d &output);

void WorldToIndex(const openvdb::math::Transform::Ptr transform, std::vector<openvdb::math::Vec3s> &points);

void WorldToIndex(const openvdb::math::Transform::Ptr transform, openvdb::math::Vec3s* points, std::size_t size);

void TransformVec3s(const Eigen::Affine3d &pose, std::vector<openvdb::math::Vec3s> &points);

void TransformVec3s(const Eigen::Affine3d& pose, openvdb::math::Vec3s* points, std::size_t size);

}

#endif //OPENVDB_DISTANCE_FIELD_H
