#ifndef OPENVDB_DISTANCE_FIELD_H
#define OPENVDB_DISTANCE_FIELD_H

#include <geometric_shapes/shapes.h>
#include <Eigen/Core>
#include <Eigen/Eigen>
#include <moveit/robot_state/robot_state.h>
#include <openvdb/openvdb.h>
#include <openvdb/tools/MeshToVolume.h>
#include <openvdb/math/Vec3.h>
#include <industrial_collision_detection/collision_common.h>
#include <openvdb_visualization.h>

namespace distance_field
{

typedef std::vector<std::pair<openvdb::math::Vec3d, double> > SphereModel;
typedef boost::shared_ptr<std::vector<std::pair<openvdb::math::Vec3d, double> > > SphereModelPtr;

struct MeshData
{
  std::vector<openvdb::math::Vec3s> points;
  std::vector<openvdb::Vec3I> triangles;
  std::vector<openvdb::Vec4I> quads;
};

class OpenVDBDistanceField
{

public:
    OpenVDBDistanceField(float voxel_size = 0.01, float background = 0.5);

    /**
     * @brief Creates a new 'OpenVDBDistanceField' using the data & meta-data associated
     * with the given grid pointer.
     * @param grid A valid pointer to a grid previously generated by this class. Should
     * contain pertinent meta-data such as 'voxel_size'.
     */
    OpenVDBDistanceField(openvdb::FloatGrid::Ptr grid);

    double getDistance(const Eigen::Vector3f &point, bool thread_safe = true) const;

    double getDistance(const openvdb::math::Coord &coord, bool thread_safe = true) const;

    double getDistance(const float &x, const float &y, const float &z, bool thread_safe = true) const;

    bool getGradient(const Eigen::Vector3f &point, Eigen::Vector3d &gradient, bool thread_safe = true) const;

    bool getGradient(const openvdb::math::Coord &coord, Eigen::Vector3d &gradient, bool thread_safe = true) const;

    bool getGradient(const float &x, const float &y, const float &z, Eigen::Vector3d &gradient, bool thread_safe = true) const;

    void addShapeToField(const shapes::Shape *shape,
                         const Eigen::Affine3d &pose,
                         const float exBandWidth = openvdb::LEVEL_SET_HALF_WIDTH,
                         const float inBandWidth = openvdb::LEVEL_SET_HALF_WIDTH);

    void addLinkToField(const robot_model::LinkModel *link,
                        const Eigen::Affine3d &pose,
                        const float exBandWidth = openvdb::LEVEL_SET_HALF_WIDTH,
                        const float inBandWidth = openvdb::LEVEL_SET_HALF_WIDTH);


    void fillWithSpheres(SphereModel &spheres,
                         int maxSphereCount,
                         bool overlapping = false,
                         float minRadius = 1.0,
                         float maxRadius = std::numeric_limits<float>::max(),
                         float isovalue = 0.0,
                         int instanceCount = 10000);

    void writeToFile(const std::string file_path);

    uint64_t memUsage() const;

    double getVoxelSize() const;

    openvdb::math::Transform::Ptr getTransform() const;

    openvdb::FloatGrid::Ptr getGrid() const;

private:

    float voxel_size_;
    float background_;
    openvdb::FloatGrid::Ptr grid_;
    std::shared_ptr<openvdb::FloatGrid::ConstAccessor> accessor_;
    openvdb::math::Transform::Ptr transform_;
};

typedef boost::shared_ptr<OpenVDBDistanceField> OpenVDBDistanceFieldPtr;
typedef boost::shared_ptr<const OpenVDBDistanceField> OpenVDBDistanceFieldConstPtr;


MeshData ShapeMeshToOpenVDB(const shapes::Mesh *mesh, const Eigen::Affine3d &pose);

void Affine3dToMat4d(const Eigen::Affine3d &input, openvdb::math::Mat4d &output);

void Affine3dToMat4dAffine(const Eigen::Affine3d &input, openvdb::math::Mat4d &output);

void WorldToIndex(const openvdb::math::Transform::Ptr transform, std::vector<openvdb::math::Vec3s> &points);

void WorldToIndex(const openvdb::math::Transform::Ptr transform, openvdb::math::Vec3s* points, std::size_t size);

void TransformVec3s(const Eigen::Affine3d &pose, std::vector<openvdb::math::Vec3s> &points);

void TransformVec3s(const Eigen::Affine3d& pose, openvdb::math::Vec3s* points, std::size_t size);


enum SDFType {Static = 0, Dynamic = 1, Active = 2};
struct DistanceQueryData
{
  DistanceQueryData() :
    empty(true),
    gradient(false) {}

  std::string parent_name;
  SphereModel spheres;
  std::vector<std::string> child_name;
  std::vector<int> child_index;
  std::vector<int> child_type;
  bool gradient;
  bool empty;
};

struct SDFData
{
  SDFData(openvdb::FloatGrid::Ptr sdf, openvdb::Mat4d &tf) : accessor(sdf->getConstAccessor())
  {
    transform = openvdb::math::Transform::createLinearTransform(tf);
    transform->preScale(sdf->transformPtr()->voxelSize());
  }

  SDFData(openvdb::FloatGrid::Ptr sdf) :
    accessor(sdf->getConstAccessor()),
    transform(sdf->transformPtr()) {}

  openvdb::math::Transform::Ptr transform;
  openvdb::FloatGrid::ConstAccessor accessor;
};

class CollisionRobotOpenVDB
{
public:
  CollisionRobotOpenVDB(const robot_model::RobotModelConstPtr &model,
                        const float voxel_size = 0.01,
                        const float background = 0.5,
                        const float exBandWidth = openvdb::LEVEL_SET_HALF_WIDTH,
                        const float inBandWidth = openvdb::LEVEL_SET_HALF_WIDTH);

  /**
   * @brief Alternative constructor that loads an already generated set of distance
   * fields given a particular robot model.
   * @param model The robot model with which to load and interpret saved fields
   * @param file_path The .vdb file that containts the archived distance fields
   */
  CollisionRobotOpenVDB(const robot_model::RobotModelConstPtr& model,
                        const std::string& file_path);

  void distanceSelf(const collision_detection::DistanceRequest &req,
                    collision_detection::DistanceResult &res, const robot_state::RobotState &state) const;

  uint64_t memUsage() const;

  void writeToFile(const std::string &file_path);

  /**
   * @brief Returns a pair of 'inside' & 'outside' distance clouds.
   * @param state The robot state to visualize
   * @return Pair of inside & outside surface point clouds visualizing voxels
   */
  std::pair<distance_field::PointCloud::Ptr, distance_field::PointCloud::Ptr>
  voxelGridToPointClouds(const moveit::core::RobotState& state) const;

  std::pair<distance_field::PointCloud::Ptr, distance_field::PointCloud::Ptr>
  voxelGridToPointClouds(const moveit::core::RobotState& state,
                         const std::vector<std::string>& exclude_list) const;

  visualization_msgs::MarkerArray spheresToVisualizationMarkers(const moveit::core::RobotState& state) const;

private:

  std::pair<openvdb::GridPtrVecPtr, openvdb::MetaMap::Ptr> readFromFile(const std::string& file_path);

  void distanceSelfHelper(const DistanceQueryData &data, std::vector<std::vector<SDFData> > &sdfs_data, collision_detection::DistanceResultsData &res) const;

  /**
   * @brief Create static signed distance fields.
   *
   * These are links attached to the world by fixed transforms or by proxy
   */
  void createStaticSDFs();

  /**
   * @brief Create active signed distance fields.
   *
   * These are links that are associated to a move_group (joint, linear, etc.). These are
   * the only links that get a sphere model.
   */
  void createActiveSDFs();

  /**
   * @brief Create dynamic signed distance fields.
   *
   * These are links that have the ability to move but are not associated to a move_group (joint, linear, etc.)
   */
  void createDynamicSDFs();

  /**
   * @brief Generate a default distance query structure.
   */
  void createDefaultDistanceQuery();

  /**
   * @brief generateDefaultAllowedCollisionMatrix
   */
  void createDefaultAllowedCollisionMatrix();

  /**
   * @brief This is a recursive helper function that creates the static signed distance field given a base link.
   *
   * @param link, The link to search for child links that are attached by fixed transform.
   */
  void addAssociatedFixedTransforms(const robot_model::LinkModel *link, std::vector<const moveit::core::LinkModel *> &links_so_far);

  bool isCollisionAllowed(const std::string &l1, const std::string &l2, const collision_detection::AllowedCollisionMatrix *acm) const;

  const robot_model::RobotModelConstPtr robot_model_;
  collision_detection::AllowedCollisionMatrixPtr acm_;

  const std::vector<const robot_model::LinkModel*>& links_;

  std::vector<OpenVDBDistanceFieldConstPtr> static_sdf_;
  std::vector<const robot_model::LinkModel*> static_links_;

  std::vector<OpenVDBDistanceFieldConstPtr> dynamic_sdf_;
  std::vector<const robot_model::LinkModel*> dynamic_links_;

  std::vector<OpenVDBDistanceFieldConstPtr> active_sdf_;
  std::vector<const robot_model::LinkModel*> active_links_;
  std::vector<SphereModel> active_spheres_;

  std::vector<DistanceQueryData> dist_query_;

  float voxel_size_;
  float background_;
  float exBandWidth_;
  float inBandWidth_;
};

}

#endif //OPENVDB_DISTANCE_FIELD_H
